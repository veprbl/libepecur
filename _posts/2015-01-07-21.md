---
layout: post
title: "Повторное изучение процедуры дрейфовой калибровки"
date: 2015-01-07 16:38:11
---

Будем работать с первой плоскостью правого плеча дрейфовых камер. Построим распределение времён дрейфа в событиях:

<pre>TFile f("23041046.root")
events-&gt;Draw("d3Y1_time");</pre>

<img src="/assets/23041046_d3Y1_time.png" alt="" width="696" height="473" />

На графике видны два горба. Откуда они берутся?

<!--break-->

Построим распределение для событий в которых в исследуемой камере есть всего одно срабатывание:

<pre>events-&gt;Draw("d3Y1_time", "d3Y1_num_wires == 1");</pre>

<img src="/assets/23041046_d3Y1_time_1hit.png" alt="" width="696" height="473" />

Видим, что эффект уменьшился. <span style="line-height: 1.5;">Аналогичное распределение для событий с двумя срабатываниями:</span>

<pre>events-&gt;Draw("d3Y1_time", "d3Y1_num_wires == 2");</pre>

<img src="/assets/23041046_d3Y1_time_2hit.png" alt="" width="696" height="473" />

Эффект виден.

На данный момент я в своём анализе принимаю за точку раздела ячеек (полный шаг 8.5мм) время в 380 отсчётов. Но мне кажется, что может быть, что раздел ячеек на самом деле происходят раньше, вероятно даже прямо около наблюдаемых горбов распределения событий.

Чтобы проверить это, продолжим работать с двуххитовыми событиями и построим распределение для только для событий в которых сработали две соседсвующие проволочки:

<pre>events-&gt;Draw("d3Y1_time", "(d3Y1_num_wires == 2) && abs(d3Y1_wire_pos[0] - d3Y1_wire_pos[1]) == 2");</pre>

<img src="/assets/23041046_d3Y1_time_2hit_adjacent.png" alt="" width="696" height="473" />

Эффект ещё более отчетливо виден.

А для двух несоседствующих<span style="line-height: 1.5;">:</span>

<pre>events-&gt;Draw("d3Y1_time", "(d3Y1_num_wires == 2) && abs(d3Y1_wire_pos[0] - d3Y1_wire_pos[1]) &gt;= 4");</pre>

<img src="/assets/23041046_d3Y1_time_2hit_separated.png" alt="" width="696" height="473" />

Снова не виден.

Итак, горбы крайне сильно выражены только в срабатываниях двух соседних проволочек.

Построим корреляцию между временами дрейфа до этих двух проволочек:

<pre>events-&gt;Draw("d3Y1_time[0]:d3Y1_time[1] &gt;&gt; h(380, 0.0, 380.0, 380, 0.0, 380.0)", "(d3Y1_num_wires == 2) && (abs(d3Y1_wire_pos[0] - d3Y1_wire_pos[1]) == 2)", "col z");</pre>

<img src="/assets/23041046_d3Y1_time_2hit_corr.png" alt="" width="696" height="608" />

Распределение лежит в основном ниже линии x=y из-за того что номера проволочек попадают в поток (почти) в порядке прихода сигнала от них. Так же на распределении видны две белые борозды, связанные с программным фильтром наводок, включенным в мой анализ.

Видимое на картинках пятно немного смахивает на корреляцию. Чтобы проверить, похоже ли это на проявление какого-то физического эффекта, я буду коррелировать наличие эффекта с физической же величиной, а именно углом трека по отношению к плоскоти камер.

Вместо использования восстановленых треков пойдём по другому, технически более простому, пути. Будем отбирать события с едниственным срабатыванием в дальней камере и смотреть на разницу координат срабатываний в ближней(исследуемой) и дальней камерах. Распределение этой разницы для однохитовых событий выглядит так:

<pre>events-&gt;Draw("d3Y1_wire_pos[0] - d3Y4_wire_pos[0] &gt;&gt; h(40, -40.0, 40.0)", "(d3Y1_num_wires == 1) && (d3Y4_num_wires == 1)");</pre>

<img src="/assets/23041046_d3Y_coarse_angle.png" alt="" width="696" height="608" />

Разделим события на события вызванные треком с маленьким углом и на события от трека с большим уголом так, чтобы наборы имели приблизительно одинаковую статистику. В данном случае будем считать за малые углы разницу положений проволочек в 14 шагов по 8.5мм. Большие разницы будем считать соотвествующми трекам с большими углами.

Для треков с малыми углами корреляция выглядит так:

<pre>events-&gt;Draw("d3Y1_time[0]:d3Y1_time[1] &gt;&gt; h(380, 0.0, 380.0, 380, 0.0, 380.0)", "(d3Y1_num_wires == 2) && (abs(d3Y1_wire_pos[0] - d3Y1_wire_pos[1]) == 2) && (d3Y4_num_wires == 1) && (abs(d3Y1_wire_pos[0] - d3Y4_wire_pos[0]) &lt; 14) ", "col z");</pre>

<img src="/assets/23041046_d3Y1_time_2hit_corr_small_angle.png" alt="" width="696" height="608" />

Для больших углов:

<pre>events-&gt;Draw("d3Y1_time[0]:d3Y1_time[1] &gt;&gt; h(380, 0.0, 380.0, 380, 0.0, 380.0)", "(d3Y1_num_wires == 2) && (abs(d3Y1_wire_pos[0] - d3Y1_wire_pos[1]) == 2) && (d3Y4_num_wires == 1) && (abs(d3Y1_wire_pos[0] - d3Y4_wire_pos[0]) &gt; 14) ", "col z");</pre>

<img src="/assets/23041046_d3Y1_time_2hit_corr_big_angle.png" alt="" width="696" height="608" />

 Видим, что для "малых" углов корреляции нет, а для "больших" она появляется. Причём наблюдаемая корреляция немного намекает на правило суммы *время\_дрейфа\_1 + время\_дрейфа\_2 = константа*. Такое правило может означать, что заряд таки может ощутимо часто делится между двумя соседними ячейками и дрейфовать одновременно к разным проволочкам.

Даже более вроятно, что подобное правило сумм можно будет гораздо лучше пронаблюдать рассматривая не соседние проволочки одной платы, а соседние проволочки соседних плат, т.к. в этом случае присутствует более полное перекрытие аксептансов ячеек для треков, идущих под малыми углами.

<table border="0">
  <tbody>
    <tr>
      <td>
        GIT_COMMIT_ID
      </td>
      
      <td>
        b86e8bd767258650775db464aeba49
      </td>
    </tr>
    
    <tr>
      <td>
        INPUT_FILE
      </td>
      
      <td>
        /Users/veprbl/23041046.dat
      </td>
    </tr>
    
    <tr>
      <td>
        GEOMETRY_FILE
      </td>
      
      <td>
        ../contrib/geom_apr10.c
      </td>
    </tr>
    
    <tr>
      <td>
        THIN_OUT_FACTOR
      </td>
      
      <td>
        1
      </td>
    </tr>
  </tbody>
</table>